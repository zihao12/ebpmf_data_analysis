---
title: "smallsim2"
author: "zihao12"
date: "2021-06-07"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

## Introduction

* I want to simulate the scenario where $n << p$ so we can treat $L$ as global parameter and $F$ as local parameter. Thus it makes sense to treat $F$ as random and $L$ as fixed. 
* I also want the simlulated $F$ to be close to my model assumption. Thus I use $f_{jk} \sim Ga(\alpha_{jk}, \alpha_{jk}); \alpha_{jk} \sim B(a_k, b_k)$. 
* With this simulated data I hope we can demonstrate `ebpmf` approach outperforms the simple `MLE` estimate.

```{r}
rm(list = ls())
library(mvtnorm)
library(NNLM)
library(fastTopics)
control <- list(extrapolate = FALSE,numiter = 4)
source("code/misc.R")
source("code/init.R")
set.seed(123)
```


```{r}
normalize.cols <- function (A)
  t(t(A) / colSums(A))

## simulate the following
## f_j ~ Ga(alpha_j, alpha_j); alpha_j ~ c * Beta(a, b)
simulate_gamma_beta <- function(a, b, c, m){
  alpha <- rbeta(n = m, shape1 = a, shape2 = b)
  f <- rgamma(n = m, shape = alpha, rate = alpha)
  return(f)
}


# Randomly generate an m x k factors matrix for a pmf with
# k topics. 
# each column is generated by f_jk ~ Ga(alpha_jk, alpha_jk); alpha_jk ~ c * Beta(a_k, b_k)
simulate_factors <- function (m, k, a, b, c, seed = 123) {
  set.seed(seed)
  if(length(a) == 1){a = replicate(k, a)}
  if(length(b) == 1){b = replicate(k, b)}
  F <- matrix(0,m,k)
  for (i in 1:k) {
    F[,i] <- simulate_gamma_beta(a = a[k], b = b[k], c = c, m = m)
  }
  return(normalize.cols(F))
}


# Randomly generate an n x k loadings matrix (i.e., mixture
# proportions matrix) for a multinomial topic model with k topics. The
# loadings are simulated from the correlated topic model with mean
# zero and k x k covariance matrix S.
simulate_loadings <- function (n, k, S) {
  L <- matrix(0,n,k)
  for (i in 1:n) {
    u <- rmvnorm(1,sigma = S)
    u <- u - max(u)
    L[i,] <- exp(u)/sum(exp(u))
  }
  return(L)
}

# Randomly generate samples sizes for the multinomial data simulation.
simulate_sizes <- function (n)
  ceiling(10^rnorm(n,3,0.20))

# Simulate counts from the multinomial topic model with factors F,
# loadings L and sample sizes s.
simulate_multinom_counts <- function (L, F, s) {
  n <- nrow(L)
  m <- nrow(F)
  X <- matrix(0,n,m)
  P <- tcrossprod(L,F)
  for (i in 1:n)
    X[i,] <- rmultinom(1,s[i],P[i,])
  return(X)
}

```

Functions to disable shrinkage in $L$
```{r}
## input is `gls` or `gfs`
## I set the weight to be concentrated on the the grid with the smallest `shape` (need to be very small)
disable_shrinkage_gs <- function(gs){
  k = length(gs)
  idx = which.min(gs[[1]]$shape)
  w = replicate(length(gs[[1]]$shape), 1e-16)
  w[idx] = 1
  w = w/sum(w)
  for(i in 1:k){
    gs[[i]]$pi = w
  }
  return(gs)
}


```





## Fit sampled data vs full
```{r}
n <- 100
m <- 300
k <- 3
n_sample = 20

S <- 13*diag(k) - 2
F <- simulate_factors(m = m, k = k, a = 0.8,b = 0.8,c = 100)
L <- simulate_loadings(n,k,S)
s <- simulate_sizes(n)
X <- simulate_multinom_counts(L,F,s)
 
fit0 = NNLM::nnmf(A = X[1:n_sample, ], k = k, loss = "mkl", method = "lee", max.iter = 50)
fit_small = nnmf(A = X[1:n_sample, ], k = k, loss = "mkl", method = "lee", init = list(H = fit0$H), max.iter = 200)
fit_big = nnmf(A = X, k = k, loss = "mkl", method = "lee", init = list(H = fit0$H), max.iter = 200)

init.eb <- initialize_qgl0f0w_from_LF.local(L = fit_small$W, F = t(fit_small$H))
init.eb$qg$gls <- disable_shrinkage_gs(init.eb$qg$gls)
fix_option = list(l0 = TRUE, f0 = FALSE, gl = TRUE, ql = TRUE, gf = FALSE, qf = FALSE) ## fixing L!
fit.eb <- ebpmf.alpha::ebpmf_wbg(X = X[1:n_sample, ], K = k, 
                                 init = init.eb, fix_option = fix_option, 
                                 maxiter = 200, verbose = TRUE)


# save(X, L,F, s, fit0, fit_small, fit_big, fit.eb, file = "output/smallsim2_1.RData")
# load("output/smallsim2_1.RData")

```


```{r}
fit_big.m = get_multinom_from_pnmf(F = t(fit_big$H), L = fit_big$W)
fit_small.m = get_multinom_from_pnmf(F = t(fit_small$H), L = fit_small$W)
fit.eb.mle = ebpmf2fastTopics_pmf(fit = fit.eb)
fit.eb.m = get_multinom_from_pnmf(F = fit.eb.mle$F, L = fit.eb.mle$L)

idx_big = match_topics(F1 = F, F2 = fit_big.m$F)
idx_big
idx_small = match_topics(F1 = F, F2 = fit_small.m$F)
idx_small
idx_eb = match_topics(F1 = F, F2 = fit.eb.m$F)
idx_eb
```


Compare topics

* We can see in big data `F` is estimated very well; in small data $\hat{F}$ is also close to the truth but it's a bit noisy

```{r}
model = fit_big.m
idx = idx_big
par(mfrow = c(3,2))
for(i in 1:k){
  f_fitted = model$F[,idx[i]]
  f_true = F[,i]
  se = sum((f_fitted - f_true)^2)
  plot(f_fitted, f_true, main = sprintf("topic %d: se %.5f", i, se))
  abline(a = 0, b = 1, col = "blue")
}
```

```{r}
model = fit_small.m
idx = idx_small
par(mfrow = c(3,2))
for(i in 1:k){
  f_fitted = model$F[,idx[i]]
  f_true = F[,i]
  se = sum((f_fitted - f_true)^2)
  plot(f_fitted, f_true, main = sprintf("topic %d: se %.5f", i, se))
  abline(a = 0, b = 1, col = "blue")
}
```

```{r}
model = fit.eb.m
idx = idx_eb
par(mfrow = c(3,2))
for(i in 1:k){
  f_fitted = model$F[,idx[i]]
  f_true = F[,i]
  se = sum((f_fitted - f_true)^2)
  plot(f_fitted, f_true, main = sprintf("topic %d: se %.5f", i, se))
  abline(a = 0, b = 1, col = "blue")
}
```



Look at $L$
```{r}
model = fit_big.m
idx = idx_big
par(mfrow = c(3,2))
for(i in 1:k){
  l_fitted = model$L[1:n_sample,idx[i]]
  l_true = L[1:n_sample,i]
  se = sum((l_fitted - l_true)^2)
  plot(l_fitted, l_true, main = sprintf("topic %d: se %.5f", i, se))
  abline(a = 0, b = 1, col = "blue")
}
```


```{r}
model = fit_small.m
idx = idx_small
par(mfrow = c(3,2))
for(i in 1:k){
  l_fitted = model$L[1:n_sample,idx[i]]
  l_true = L[1:n_sample,i]
  se = sum((l_fitted - l_true)^2)
  plot(l_fitted, l_true, main = sprintf("topic %d: se %.5f", i, se))
  abline(a = 0, b = 1, col = "blue")
}
```


```{r}
model = fit.eb.m
idx = idx_eb
par(mfrow = c(3,2))
for(i in 1:k){
  l_fitted = model$L[1:n_sample,idx[i]]
  l_true = L[1:n_sample,i]
  se = sum((l_fitted - l_true)^2)
  plot(l_fitted, l_true, main = sprintf("topic %d: se %.5f", i, se))
  abline(a = 0, b = 1, col = "blue")
}
```





